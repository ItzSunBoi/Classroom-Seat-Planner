<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seating Planner</title>
  <style>
    :root{
      --bg:#eef6ff;
      --panel:#ffffff;
      --text:#0b1b33;
      --muted:#4b6b93;
      --border:#cfe2ff;
      --blue:#1d4ed8;
      --blue2:#0b2f6b;
      --chip:#e7f1ff;
      --bad:#b91c1c;
      --good:#0f766e;
      --shadow:0 10px 30px rgba(9,30,66,.08);
      --cell:42px;
      --radius:16px;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#071428;
        --panel:#0b1f3b;
        --text:#e8f1ff;
        --muted:#9ab6da;
        --border:#163a6a;
        --blue:#60a5fa;
        --blue2:#93c5fd;
        --chip:#0f2a50;
        --shadow:0 12px 30px rgba(0,0,0,.35);
      }
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{max-width:1240px;margin:0 auto;padding:18px;}

    header{
      display:flex;align-items:center;justify-content:space-between;gap:14px;
      padding:14px 16px;background:linear-gradient(135deg,var(--panel),rgba(255,255,255,0));
      border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);
    }
    .title{
      display:flex;flex-direction:column;gap:2px;
    }
    .title h1{margin:0;font-size:18px;letter-spacing:.2px}
    .title p{margin:0;font-size:12px;color:var(--muted)}

    .actions{display:flex;flex-wrap:wrap;gap:10px;align-items:center}

    button, .btn{
      appearance:none;border:1px solid var(--border);background:var(--panel);
      color:var(--text);padding:10px 12px;border-radius:12px;
      font-weight:600;font-size:12px;cursor:pointer;
      transition:transform .05s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    button:hover{border-color:rgba(29,78,216,.55)}
    button:active{transform:translateY(1px)}
    button.primary{background:linear-gradient(180deg,var(--blue),var(--blue2));border-color:transparent;color:white}
    button.danger{border-color:rgba(185,28,28,.35);color:var(--bad)}

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .95fr;
      gap:16px;
      margin-top:16px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px;
      min-width:0;
    }

    .card h2{margin:0 0 10px 0;font-size:13px;letter-spacing:.2px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}

    label{font-size:12px;color:var(--muted)}
    input[type="number"], input[type="text"], select, textarea{
      width:auto;min-width:80px;
      padding:9px 10px;border-radius:12px;
      border:1px solid var(--border);
      background:transparent;color:var(--text);
      outline:none;
      font-size:12px;
    }
    textarea{width:100%;min-height:160px;resize:vertical;line-height:1.35}

    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--border);
      border-radius:999px;background:var(--chip);
      font-size:12px;color:var(--muted);
    }

    .split{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }

    .mapWrap{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }

    .mapToolbar{
      display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;
    }
    .toolgroup{display:flex;flex-wrap:wrap;gap:8px;align-items:center}

    .toolBtn{
      padding:8px 10px;border-radius:12px;border:1px solid var(--border);
      background:transparent;color:var(--text);font-size:12px;font-weight:700;
    }
    .toolBtn[aria-pressed="true"]{
      background:linear-gradient(180deg, rgba(29,78,216,.18), rgba(29,78,216,.06));
      border-color:rgba(29,78,216,.45);
      color:var(--text);
    }

    .map{
      display:grid;
      grid-template-columns: repeat(var(--cols), var(--cell));
      grid-auto-rows: var(--cell);
      gap:8px;
      align-content:start;
      padding:12px;
      border-radius:var(--radius);
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.35), rgba(255,255,255,0));
      overflow:auto;
      max-height: 74vh;
    }

    .cell{
      width:var(--cell);height:var(--cell);
      border-radius:14px;
      border:1px solid var(--border);
      display:flex;align-items:center;justify-content:center;
      position:relative;
      font-size:12px;font-weight:800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
      background:rgba(255,255,255,.18);
    }
    .cell:hover{border-color:rgba(29,78,216,.55)}

    .cell.blocked{background:rgba(185,28,28,.08);border-color:rgba(185,28,28,.25)}
    .cell.teacher{background:rgba(29,78,216,.12);border-color:rgba(29,78,216,.35)}
    .cell.seat{background:rgba(15,118,110,.10);border-color:rgba(15,118,110,.25)}

    .badge{
      position:absolute;top:6px;left:6px;
      font-size:10px;font-weight:900;
      color:var(--muted);
      background:rgba(255,255,255,.25);
      border:1px solid var(--border);
      padding:2px 6px;border-radius:999px;
    }

    .occ{
      position:absolute;
      font-size:10px;font-weight:900;
      color:var(--text);
      background:rgba(29,78,216,.12);
      border:1px solid rgba(29,78,216,.25);
      padding:2px 6px;border-radius:999px;
    }

    .status{
      display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;
      padding:10px 12px;border-radius:14px;border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(29,78,216,.10), rgba(29,78,216,.03));
    }
    .status strong{font-size:12px}
    .status .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;color:var(--muted)}

    .hint{margin:0;font-size:12px;color:var(--muted);line-height:1.45}

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){
      .twoCol{grid-template-columns:1fr}
    }

    .small{font-size:11px;color:var(--muted)}
    .kpi{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .kpi .pill{background:transparent}

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:var(--panel);border:1px solid var(--border);box-shadow:var(--shadow);
      padding:10px 12px;border-radius:12px;font-size:12px;color:var(--text);
      opacity:0;pointer-events:none;transition:opacity .18s ease, transform .18s ease;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}

    /* E-ink preview mode (high contrast) */
    body.eink{
      --bg:#ffffff;
      --panel:#ffffff;
      --text:#000000;
      --muted:#111111;
      --border:#111111;
      --blue:#000000;
      --blue2:#000000;
      --chip:#ffffff;
      --shadow:none;
    }
    body.eink .cell{background:#fff;border-color:#000}
    body.eink .cell.blocked{background:#fff;border-color:#000}
    body.eink .cell.teacher{background:#fff;border-color:#000}
    body.eink .cell.seat{background:#fff;border-color:#000}
    body.eink button.primary{background:#000;color:#fff}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Seating Planner</h1>
        <p>Client-side optimiser (simulated annealing). Front of room is the top of the grid.</p>
      </div>
      <div class="actions">
        <button id="btnSolve" class="primary">Solve</button>
        <button id="btnStep">Quick Improve</button>
        <button id="btnShuffle">Shuffle</button>
        <button id="btnExport">Export JSON</button>
        <button id="btnImport">Import JSON</button>
        <button id="btnReset" class="danger">Reset</button>
        <button id="btnEink">E‑Ink Preview</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT: MAP -->
      <section class="card mapWrap">
        <div class="mapToolbar">
          <div class="toolgroup">
            <span class="pill"><strong>Map</strong> · edit tiles</span>
            <button class="toolBtn" data-tool="seat" aria-pressed="true">Seat</button>
            <button class="toolBtn" data-tool="blocked" aria-pressed="false">Blocked</button>
            <button class="toolBtn" data-tool="teacher" aria-pressed="false">Teacher</button>
            <button class="toolBtn" data-tool="empty" aria-pressed="false">Empty</button>
          </div>
          <div class="toolgroup">
            <label>Rows <input id="inpRows" type="number" min="1" max="40" value="8" /></label>
            <label>Cols <input id="inpCols" type="number" min="1" max="40" value="10" /></label>
            <label>Cell <input id="inpCell" type="number" min="28" max="64" value="42" /></label>
            <button id="btnResize">Resize Grid</button>
          </div>
        </div>

        <div class="status" style="margin-top:6px">
          <div class="kpi">
            <span class="pill">Seats: <strong id="kpiSeats">0</strong></span>
            <span class="pill">Pupils: <strong id="kpiPupils">0</strong></span>
            <span class="pill">Hard breaks: <strong id="kpiHard">0</strong></span>
            <span class="pill">Score: <strong id="kpiScore">0</strong></span>
          </div>
          <div class="mono" id="kpiMsg">Ready.</div>
        </div>

        <div id="map" class="map" aria-label="room grid"></div>
        <p class="hint">Tip: Click tiles to paint. Seats are where pupils can sit. Teacher tiles let you add distance-to-teacher rules. Export JSON to persist on the ESP32 (e.g., in SPIFFS/LittleFS).</p>
      </section>

      <!-- RIGHT: DATA + RULES -->
      <aside class="card split">
        <div>
          <h2>Pupils</h2>
          <div class="row" style="justify-content:space-between;margin-bottom:10px">
            <div class="row">
              <input id="inpPupilId" type="text" placeholder="ID (e.g., A12)" />
              <input id="inpPupilTags" type="text" placeholder="tags (comma)" />
              <button id="btnAddPupil">Add</button>
            </div>
            <button id="btnAutoFill">Demo Pupils</button>
          </div>
          <textarea id="txtPupils" spellcheck="false"></textarea>
          <p class="small">Format: JSON array of pupils: <span class="mono">[{"id":"A","tags":["needs_front"],"fixed":null}]</span>. Fixed can be <span class="mono">{"seat":"S1_0"}</span> or <span class="mono">{"r":1,"c":0}</span>.</p>
        </div>

        <div>
          <h2>Rules</h2>
          <div class="twoCol" style="margin-bottom:10px">
            <div>
              <label>Quick rule template</label><br/>
              <select id="selRuleTpl">
                <option value="mindist">Min distance (A from B)</option>
                <option value="maxdist">Max distance (A near B)</option>
                <option value="notadj">Not adjacent</option>
                <option value="preferfront">Prefer front rows</option>
                <option value="awayteacher">Away from teacher</option>
                <option value="tagsep">Spread tag group</option>
                <option value="mustrows">Must be within rows</option>
              </select>
            </div>
            <div>
              <label>&nbsp;</label><br/>
              <button id="btnAddRule">Add rule</button>
            </div>
          </div>

          <textarea id="txtRules" spellcheck="false"></textarea>
          <p class="small">Rules are JSON objects. Each rule supports <span class="mono">hard</span> and <span class="mono">weight</span>. Hard violations dominate the score.</p>
        </div>

        <div>
          <h2>Solver settings</h2>
          <div class="row" style="gap:10px">
            <label>Restarts <input id="inpRestarts" type="number" min="1" max="80" value="25" /></label>
            <label>Iters/restart <input id="inpIters" type="number" min="100" max="300000" value="25000" /></label>
            <label>Start T <input id="inpT0" type="number" min="0.1" step="0.1" value="6.0" /></label>
            <label>End T <input id="inpT1" type="number" min="0.001" step="0.01" value="0.05" /></label>
            <label>Seed <input id="inpSeed" type="number" min="0" value="12345" /></label>
          </div>
          <p class="hint" style="margin-top:10px">“Quick Improve” runs a short optimisation pass without restarts. Use it after manual tweaks.</p>
        </div>
      </aside>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
  // =====================================
  // Seating Planner — pure client-side JS
  // =====================================

  // --------- Utilities ---------
  const $ = (id) => document.getElementById(id);
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 1400);
  }

  function stableStringify(obj){
    // Stable-ish stringify for localStorage diff friendliness
    return JSON.stringify(obj, Object.keys(obj).sort(), 2);
  }

  // --------- Distance metrics ---------
  const dist = {
    manhattan: (a,b) => Math.abs(a.r-b.r) + Math.abs(a.c-b.c),
    chebyshev: (a,b) => Math.max(Math.abs(a.r-b.r), Math.abs(a.c-b.c)),
    euclidean2: (a,b) => { const dr=a.r-b.r, dc=a.c-b.c; return dr*dr + dc*dc; },
  };

  // --------- Model ---------
  const MODEL_VERSION = 1;

  const state = {
    room: {
      rows: 8,
      cols: 10,
      cell: 42,
      blocked: new Set(),
      teacher: new Set(),
      // seats: Map key "r,c" => seatId string
      seats: new Map(),
    },
    pupils: [],  // [{id, tags:[], fixed:null|{seat}|{r,c}}]
    rules: [],   // rule objects
    assignment: {}, // pupilId -> seatId
    tool: "seat",
  };

  function keyRC(r,c){ return `${r},${c}`; }

  function seatIdFor(r,c){ return `S${String(r).padStart(2,"0")}_${String(c).padStart(2,"0")}`; }

  function parseJSONText(text, fallback){
    try{ return JSON.parse(text); }catch(e){ return fallback; }
  }

  function saveLocal(){
    const payload = exportJSON();
    localStorage.setItem("seating_planner_v"+MODEL_VERSION, JSON.stringify(payload));
  }

  function loadLocal(){
    const raw = localStorage.getItem("seating_planner_v"+MODEL_VERSION);
    if(!raw) return false;
    try{
      importJSON(JSON.parse(raw));
      return true;
    }catch(e){
      console.warn(e);
      return false;
    }
  }

  // --------- Room helpers ---------
  function isBlocked(r,c){ return state.room.blocked.has(keyRC(r,c)); }
  function isTeacher(r,c){ return state.room.teacher.has(keyRC(r,c)); }
  function isSeat(r,c){ return state.room.seats.has(keyRC(r,c)); }

  function ensureSeat(r,c){
    const k = keyRC(r,c);
    if(isBlocked(r,c)) state.room.blocked.delete(k);
    state.room.seats.set(k, seatIdFor(r,c));
  }
  function ensureBlocked(r,c){
    const k = keyRC(r,c);
    state.room.seats.delete(k);
    state.room.teacher.delete(k);
    state.room.blocked.add(k);
  }
  function ensureTeacher(r,c){
    const k = keyRC(r,c);
    if(isBlocked(r,c)) state.room.blocked.delete(k);
    state.room.teacher.add(k);
  }
  function ensureEmpty(r,c){
    const k = keyRC(r,c);
    state.room.seats.delete(k);
    state.room.teacher.delete(k);
    state.room.blocked.delete(k);
  }

  function allSeatIds(){
    return Array.from(state.room.seats.values());
  }

  function seatPosById(seatId){
    // seatId format: Srr_cc
    const m = /^S(\d{2})_(\d{2})$/.exec(seatId);
    if(!m) return null;
    return {r: parseInt(m[1],10), c: parseInt(m[2],10)};
  }

  // --------- Assignment ---------
  function buildInitialAssignment(seed){
    const rng = mulberry32(seed >>> 0);
    const pupils = getPupils();
    const seats = allSeatIds();

    // fixed placements
    const used = new Set();
    const assign = {};

    // helper: fixed rc -> seat id
    function rcToSeatId(r,c){
      const k = keyRC(r,c);
      if(!state.room.seats.has(k)) throw new Error(`fixed r,c (${r},${c}) is not a seat`);
      return state.room.seats.get(k);
    }

    for(const p of pupils){
      if(p.fixed && p.fixed.seat){
        const sid = p.fixed.seat;
        if(!seats.includes(sid)) throw new Error(`fixed seat ${sid} not in map`);
        if(used.has(sid)) throw new Error(`seat ${sid} fixed twice`);
        assign[p.id]=sid; used.add(sid);
      } else if(p.fixed && ("r" in p.fixed) && ("c" in p.fixed)){
        const sid = rcToSeatId(p.fixed.r, p.fixed.c);
        if(used.has(sid)) throw new Error(`seat ${sid} fixed twice`);
        assign[p.id]=sid; used.add(sid);
      }
    }

    // remaining seats
    const free = seats.filter(s=>!used.has(s));

    // Split pupils:
    //  - tagged pupils (any tags) are placed first (uniform random over remaining seats)
    //  - then all other pupils are placed with a FRONT-BIASED random (more likely near the top/front)
    const remainingPupils = pupils.filter(p=>!assign[p.id]);
    const tagged = remainingPupils.filter(p => Array.isArray(p.tags) && p.tags.length>0).map(p=>p.id);
    const untagged = remainingPupils.filter(p => !(Array.isArray(p.tags) && p.tags.length>0)).map(p=>p.id);

    if((tagged.length + untagged.length) > free.length){
      throw new Error(`Not enough seats (${seats.length}) for pupils (${pupils.length})`);
    }

    // 1) Place tagged pupils (uniform random)
    shuffleInPlace(free, rng);
    let idx = 0;
    for(const pid of tagged){
      assign[pid] = free[idx++];
    }

    // 2) Place untagged pupils (front-to-back flood fill)
    // Classroom-style fill: after priority placements, fill the remaining seats
    // starting from the front row (row 0) moving backwards.
    // Optional: keep a little randomness *within the same row* so it doesn't look too artificial.

    const free2 = free.slice(idx);

    // Sort seats by row asc (front->back), then col asc (left->right)
    free2.sort((sa, sb) => {
      const a = seatPosById(sa);
      const b = seatPosById(sb);
      if(!a && !b) return 0;
      if(!a) return 1;
      if(!b) return -1;
      if(a.r !== b.r) return a.r - b.r;
      return a.c - b.c;
    });

    // Mild within-row shuffle toggle (set to 0 for strict left-to-right)
    const WITHIN_ROW_SHUFFLE = 1;

    if(WITHIN_ROW_SHUFFLE){
      // Group seats by row, shuffle each row block to mimic "fill tables" feel
      let i0 = 0;
      while(i0 < free2.length){
        const p0 = seatPosById(free2[i0]);
        let i1 = i0 + 1;
        while(i1 < free2.length){
          const p1 = seatPosById(free2[i1]);
          if(!p0 || !p1 || p1.r !== p0.r) break;
          i1++;
        }
        // shuffle [i0, i1)
        const slice = free2.slice(i0, i1);
        shuffleInPlace(slice, rng);
        for(let k=0;k<slice.length;k++) free2[i0+k] = slice[k];
        i0 = i1;
      }
    }

    // Assign sequentially (flood fill)
    for(let i=0; i<untagged.length; i++){
      assign[untagged[i]] = free2[i];
    }

    return assign;
  }

  function isFixedPupil(p){
    return !!(p.fixed && (p.fixed.seat || ("r" in p.fixed)));
  }

  function invertAssignment(assign){
    const inv = {};
    for(const [pid,sid] of Object.entries(assign)) inv[sid]=pid;
    return inv;
  }

  // --------- Constraints / rules engine ---------
  const HARD_MULT = 1_000_000;

  function rulePenalty(rule, assign, pupilsById, teacherTiles){
    const type = rule.type;
    const hard = !!rule.hard;
    const weight = Math.max(1, rule.weight|0);

    function posOf(pid){
      const sid = assign[pid];
      if(!sid) return null;
      return seatPosById(sid);
    }

    let p = 0;

    if(type === "MinDistance"){
      const a=rule.a, b=rule.b, dNeed=rule.d|0, metric=rule.metric||"manhattan";
      const pa=posOf(a), pb=posOf(b);
      if(!pa||!pb) p=0;
      else{
        const d = dist[metric](pa,pb);
        p = d>=dNeed ? 0 : (dNeed - d);
      }
    }
    else if(type === "MaxDistance"){
      const a=rule.a, b=rule.b, dMax=rule.d|0, metric=rule.metric||"manhattan";
      const pa=posOf(a), pb=posOf(b);
      if(!pa||!pb) p=0;
      else{
        const d = dist[metric](pa,pb);
        p = d<=dMax ? 0 : (d - dMax);
      }
    }
    else if(type === "NotAdjacent"){
      const a=rule.a, b=rule.b;
      const pa=posOf(a), pb=posOf(b);
      if(!pa||!pb) p=0;
      else p = dist.chebyshev(pa,pb) >= 2 ? 0 : 1;
    }
    else if(type === "PreferFront"){
      // Soft: prefer in first k rows (front=top)
      const pid=rule.pupil_id, k=rule.k|0;
      const pp=posOf(pid);
      if(!pp) p=0;
      else p = (pp.r < k) ? 0 : 1;
    }
    else if(type === "PreferAwayFromTeacher"){
      const pid=rule.pupil_id, minD=rule.min_d|0, metric=rule.metric||"manhattan";
      const pp=posOf(pid);
      if(!pp || teacherTiles.length===0) p=0;
      else{
        let best = Infinity;
        for(const t of teacherTiles){
          best = Math.min(best, dist[metric](pp, t));
        }
        p = best >= minD ? 0 : (minD - best);
      }
    }
    else if(type === "MustBeInRows"){
      const pid=rule.pupil_id, rMin=rule.r_min|0, rMax=rule.r_max|0;
      const pp=posOf(pid);
      if(!pp) p=0;
      else p = (pp.r>=rMin && pp.r<=rMax) ? 0 : 1;
    }
    else if(type === "MustBeInSeats"){
      const pid=rule.pupil_id;
      const allowed = new Set(rule.allowed_seat_ids||[]);
      const sid = assign[pid];
      if(!sid) p=0;
      else p = allowed.has(sid) ? 0 : 1;
    }
    else if(type === "TagSeparation"){
      const tag = rule.tag;
      const minD = rule.min_d|0;
      const metric = rule.metric||"manhattan";
      const tagged = [];
      for(const p0 of Object.values(pupilsById)){
        if((p0.tags||[]).includes(tag) && assign[p0.id]) tagged.push(p0.id);
      }
      let pen = 0;
      for(let i=0;i<tagged.length;i++){
        for(let j=i+1;j<tagged.length;j++){
          const pa=posOf(tagged[i]);
          const pb=posOf(tagged[j]);
          if(!pa||!pb) continue;
          const d = dist[metric](pa,pb);
          if(d < minD) pen += (minD - d);
        }
      }
      p = pen;
    }
    else {
      // Unknown rule type => ignore (safe)
      p = 0;
    }

    if(p<=0) return 0;
    return hard ? (p * HARD_MULT) : (p * weight);
  }

  function scoreAssignment(assign){
    const pupils = getPupils();
    const pupilsById = Object.fromEntries(pupils.map(p=>[p.id,p]));

    const teacherTiles = Array.from(state.room.teacher).map(k=>{
      const [r,c]=k.split(",").map(Number);
      return {r,c};
    });

    let total = 0;
    let hardBreaks = 0;
    for(const rule of getRules()){
      const rawType = rule.type;
      const pen = rulePenalty(rule, assign, pupilsById, teacherTiles);
      total += pen;
      if(pen>=HARD_MULT && rule.hard) hardBreaks += 1;
      // (Note: hardBreaks counts rule objects violated, not magnitude)
    }
    return { total, hardBreaks };
  }

  // --------- Solver (Simulated Annealing + restarts) ---------

  function solve({restarts, itersPerRestart, t0, t1, seed, progressCb}){
    const pupils = getPupils();
    if(pupils.length === 0) throw new Error("No pupils.");
    const seats = allSeatIds();
    if(seats.length === 0) throw new Error("No seats in map.");
    if(pupils.length > seats.length) throw new Error(`Not enough seats (${seats.length}) for pupils (${pupils.length}).`);

    const fixedSet = new Set(pupils.filter(isFixedPupil).map(p=>p.id));

    let bestGlobal = null;
    let bestScore = Infinity;
    let bestHard = Infinity;

    const masterRng = mulberry32(seed >>> 0);

    for(let r=0;r<restarts;r++){
      const restartSeed = Math.floor(masterRng()*0xFFFFFFFF) >>> 0;
      const rng = mulberry32(restartSeed);

      let cur = buildInitialAssignment(restartSeed);
      let curSc = scoreAssignment(cur);

      let bestLocal = cur;
      let bestLocalSc = curSc;

      const ratio = itersPerRestart>1 ? Math.pow(t1 / t0, 1/(itersPerRestart-1)) : 1;
      let T = t0;

      for(let i=0;i<itersPerRestart;i++){
        // propose a swap between two non-fixed pupils
        const movable = pupils.filter(p=>!fixedSet.has(p.id)).map(p=>p.id);
        if(movable.length < 2) break;

        const a = movable[Math.floor(rng()*movable.length)];
        let b = a;
        while(b===a) b = movable[Math.floor(rng()*movable.length)];

        const next = {...cur};
        const sa = next[a], sb = next[b];
        next[a] = sb; next[b] = sa;

        const nextSc = scoreAssignment(next);
        const delta = nextSc.total - curSc.total;

        let accept = false;
        if(delta <= 0) accept = true;
        else {
          const p = Math.exp(-delta / Math.max(1e-9, T));
          accept = (rng() < p);
        }

        if(accept){
          cur = next;
          curSc = nextSc;
          if(curSc.total < bestLocalSc.total){
            bestLocal = cur;
            bestLocalSc = curSc;
            if(bestLocalSc.total === 0) break;
          }
        }

        T *= ratio;
      }

      // keep global best
      if(bestLocalSc.total < bestScore){
        bestScore = bestLocalSc.total;
        bestHard = bestLocalSc.hardBreaks;
        bestGlobal = bestLocal;
      }

      progressCb?.({restart: r+1, restarts, bestScore, bestHard});
      if(bestScore === 0) break;
    }

    return { assignment: bestGlobal, bestScore, bestHard };
  }

  function quickImprove({iters, t0, t1, seed, progressCb}){
    // One restart, starting from current assignment if available.
    const pupils = getPupils();
    const fixedSet = new Set(pupils.filter(isFixedPupil).map(p=>p.id));

    let cur = Object.keys(state.assignment||{}).length ? {...state.assignment} : buildInitialAssignment(seed);
    // ensure assignment covers all pupils (e.g., after edits)
    cur = repairAssignment(cur, seed);

    let curSc = scoreAssignment(cur);
    let best = cur;
    let bestSc = curSc;

    const rng = mulberry32(seed >>> 0);
    const ratio = iters>1 ? Math.pow(t1/t0, 1/(iters-1)) : 1;
    let T = t0;

    const movable = pupils.filter(p=>!fixedSet.has(p.id)).map(p=>p.id);
    for(let i=0;i<iters;i++){
      if(movable.length < 2) break;
      const a = movable[Math.floor(rng()*movable.length)];
      let b=a; while(b===a) b = movable[Math.floor(rng()*movable.length)];

      const next = {...cur};
      const sa=next[a], sb=next[b];
      next[a]=sb; next[b]=sa;

      const nextSc = scoreAssignment(next);
      const delta = nextSc.total - curSc.total;
      let accept=false;
      if(delta<=0) accept=true;
      else accept = (rng() < Math.exp(-delta/Math.max(1e-9,T)));

      if(accept){
        cur = next; curSc = nextSc;
        if(curSc.total < bestSc.total){ best = cur; bestSc = curSc; }
      }
      T *= ratio;
      if(i % 200 === 0) progressCb?.({i, iters, bestScore: bestSc.total, hard: bestSc.hardBreaks});
    }

    return { assignment: best, bestScore: bestSc.total, bestHard: bestSc.hardBreaks };
  }

  function repairAssignment(assign, seed){
    // Ensure all pupils have seats and no duplicates; respects fixed.
    const rng = mulberry32(seed >>> 0);
    const pupils = getPupils();
    const seats = allSeatIds();

    const used = new Set();
    const fixed = new Map();

    // apply fixed
    for(const p of pupils){
      if(p.fixed?.seat){ fixed.set(p.id, p.fixed.seat); }
      else if(p.fixed && ("r" in p.fixed) && ("c" in p.fixed)){
        const k = keyRC(p.fixed.r, p.fixed.c);
        if(!state.room.seats.has(k)) throw new Error(`fixed r,c (${p.fixed.r},${p.fixed.c}) is not a seat`);
        fixed.set(p.id, state.room.seats.get(k));
      }
    }

    // clear duplicates & invalid seats
    const clean = {};
    for(const p of pupils){
      const pid = p.id;
      if(fixed.has(pid)){
        const sid = fixed.get(pid);
        if(used.has(sid)) throw new Error(`seat ${sid} fixed twice`);
        clean[pid]=sid; used.add(sid);
      } else {
        const sid = assign[pid];
        if(sid && seats.includes(sid) && !used.has(sid)){
          clean[pid]=sid; used.add(sid);
        }
      }
    }

    // fill rest
    const free = seats.filter(s=>!used.has(s));
    shuffleInPlace(free, rng);
    let idx=0;
    for(const p of pupils){
      if(clean[p.id]) continue;
      if(idx>=free.length) throw new Error("Not enough seats to repair assignment");
      clean[p.id]=free[idx++];
    }

    return clean;
  }

  // --------- Random helpers ---------
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function shuffleInPlace(arr, rng){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(rng() * (i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
  }

  // Weighted random pick (index) from an array, given a weight function.
  // Uses roulette-wheel selection; weights do not need to sum to 1.
  function weightedPickIndex(arr, weightFn, rng){
    let total = 0;
    const w = new Array(arr.length);
    for(let i=0;i<arr.length;i++){
      const wi = Math.max(0, Number(weightFn(arr[i], i)) || 0);
      w[i] = wi;
      total += wi;
    }
    if(total <= 0){
      // fall back to uniform
      return Math.floor(rng() * arr.length);
    }
    let r = rng() * total;
    for(let i=0;i<w.length;i++){
      r -= w[i];
      if(r <= 0) return i;
    }
    return w.length - 1;
  }

  // --------- UI binding ---------
  function setTool(tool){
    state.tool = tool;
    for(const btn of document.querySelectorAll(".toolBtn")){
      const on = btn.dataset.tool === tool;
      btn.setAttribute("aria-pressed", on ? "true" : "false");
    }
  }

  function rebuildMap(){
    const map = $("map");
    map.style.setProperty("--cols", String(state.room.cols));
    map.style.setProperty("--cell", state.room.cell + "px");
    map.innerHTML = "";

    const inv = invertAssignment(state.assignment||{});

    for(let r=0;r<state.room.rows;r++){
      for(let c=0;c<state.room.cols;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.r = String(r);
        cell.dataset.c = String(c);

        const k = keyRC(r,c);
        const seatId = state.room.seats.get(k);

        if(isBlocked(r,c)) cell.classList.add("blocked");
        if(isTeacher(r,c)) cell.classList.add("teacher");
        if(isSeat(r,c)) cell.classList.add("seat");

        // badge label
        if(isSeat(r,c)){
        //   const b = document.createElement("div");
        //   b.className = "badge";
        //   b.textContent = seatId.replace(/^S/,"");
        //   cell.appendChild(b);

          const occ = inv[seatId];
          if(occ){
            const o = document.createElement("div");
            o.className = "occ";
            o.textContent = occ;
            cell.appendChild(o);
          }
        } else if(isTeacher(r,c)){
          cell.textContent = "T";
        } else if(isBlocked(r,c)){
          cell.textContent = "";
        } else {
          cell.textContent = "";
        }

        cell.addEventListener("click", onCellClick);
        map.appendChild(cell);
      }
    }

    updateKPIs();
  }

  function onCellClick(e){
    const r = parseInt(e.currentTarget.dataset.r,10);
    const c = parseInt(e.currentTarget.dataset.c,10);

    if(state.tool === "seat") ensureSeat(r,c);
    else if(state.tool === "blocked") ensureBlocked(r,c);
    else if(state.tool === "teacher") ensureTeacher(r,c);
    else ensureEmpty(r,c);

    // After map change, repair assignment so it's always valid
    try{
      state.assignment = repairAssignment(state.assignment||{}, Number($("inpSeed").value||12345));
    }catch(err){
      // If repair fails (e.g., no seats), clear assignment
      state.assignment = {};
    }

    syncTextAreas();
    rebuildMap();
    saveLocal();
  }

  function updateKPIs(msg){
    const seats = allSeatIds().length;
    const pupils = getPupils().length;
    $("kpiSeats").textContent = String(seats);
    $("kpiPupils").textContent = String(pupils);

    const sc = (Object.keys(state.assignment||{}).length) ? scoreAssignment(state.assignment) : {total:0, hardBreaks:0};
    $("kpiHard").textContent = String(sc.hardBreaks);
    $("kpiScore").textContent = String(sc.total);
    $("kpiMsg").textContent = msg || (sc.total===0 && pupils>0 ? "Perfect score." : "Ready.");
  }

  function getPupils(){
    // authoritative from textarea
    const raw = $("txtPupils").value.trim();
    const parsed = parseJSONText(raw, []);
    const pupils = Array.isArray(parsed) ? parsed : [];
    // normalise
    return pupils.map(p => ({
      id: String(p.id||p.pupil_id||""),
      tags: Array.isArray(p.tags) ? p.tags.map(String) : [],
      fixed: p.fixed ?? null,
    })).filter(p => p.id.length>0);
  }

  function getRules(){
    const raw = $("txtRules").value.trim();
    const parsed = parseJSONText(raw, []);
    const rules = Array.isArray(parsed) ? parsed : [];
    return rules.map(r => ({
      type: String(r.type||""),
      name: r.name ?? r.type,
      hard: !!r.hard,
      weight: (r.weight==null ? 1 : (r.weight|0)),
      ...r,
    })).filter(r => r.type.length>0);
  }

  function syncTextAreas(){
    // Pupils
    if(!$("txtPupils").dataset.dirty){
      $("txtPupils").value = JSON.stringify(state.pupils, null, 2);
    }
    if(!$("txtRules").dataset.dirty){
      $("txtRules").value = JSON.stringify(state.rules, null, 2);
    }
  }

  function readTextAreasIntoState(){
    state.pupils = getPupils();
    state.rules = getRules();
  }

  // --------- Export / Import ---------
  function exportJSON(){
    readTextAreasIntoState();

    // serialise sets/maps
    const room = {
      rows: state.room.rows,
      cols: state.room.cols,
      cell: state.room.cell,
      blocked: Array.from(state.room.blocked),
      teacher: Array.from(state.room.teacher),
      seats: Array.from(state.room.seats.entries()),
    };

    return {
      version: MODEL_VERSION,
      room,
      pupils: state.pupils,
      rules: state.rules,
      assignment: state.assignment,
    };
  }

  function importJSON(obj){
    if(!obj || typeof obj !== "object") throw new Error("Invalid JSON");

    const room = obj.room || {};
    state.room.rows = clamp(room.rows|0 || 8, 1, 40);
    state.room.cols = clamp(room.cols|0 || 10, 1, 40);
    state.room.cell = clamp(room.cell|0 || 42, 28, 64);

    state.room.blocked = new Set(Array.isArray(room.blocked) ? room.blocked : []);
    state.room.teacher = new Set(Array.isArray(room.teacher) ? room.teacher : []);

    state.room.seats = new Map();
    if(Array.isArray(room.seats)){
      for(const [k,v] of room.seats){
        state.room.seats.set(String(k), String(v));
      }
    }

    state.pupils = Array.isArray(obj.pupils) ? obj.pupils : [];
    state.rules = Array.isArray(obj.rules) ? obj.rules : [];
    state.assignment = obj.assignment && typeof obj.assignment === "object" ? obj.assignment : {};

    // Push to inputs
    $("inpRows").value = String(state.room.rows);
    $("inpCols").value = String(state.room.cols);
    $("inpCell").value = String(state.room.cell);

    $("txtPupils").dataset.dirty = "";
    $("txtRules").dataset.dirty = "";
    $("txtPupils").value = JSON.stringify(state.pupils, null, 2);
    $("txtRules").value = JSON.stringify(state.rules, null, 2);

    // repair assignment
    try{ state.assignment = repairAssignment(state.assignment, Number($("inpSeed").value||12345)); }
    catch{ state.assignment = {}; }

    rebuildMap();
    saveLocal();
  }

  // --------- Rule templates ---------
  function addRuleTemplate(){
    const tpl = $("selRuleTpl").value;
    const rules = getRules();

    const pupils = getPupils().map(p=>p.id);
    const a = pupils[0] || "A";
    const b = pupils[1] || "B";

    let rule;
    if(tpl === "mindist") rule = {type:"MinDistance", name:"A far from B", hard:true, a, b, d:3, metric:"manhattan"};
    if(tpl === "maxdist") rule = {type:"MaxDistance", name:"A near B", hard:false, weight:2, a, b, d:3, metric:"manhattan"};
    if(tpl === "notadj") rule = {type:"NotAdjacent", name:"Not adjacent", hard:true, a, b};
    if(tpl === "preferfront") rule = {type:"PreferFront", name:"Prefer front", hard:false, weight:3, pupil_id:a, k:2};
    if(tpl === "awayteacher") rule = {type:"PreferAwayFromTeacher", name:"Away from teacher", hard:false, weight:2, pupil_id:a, min_d:3, metric:"manhattan"};
    if(tpl === "tagsep") rule = {type:"TagSeparation", name:"Spread tag", hard:false, weight:5, tag:"talkative", min_d:4, metric:"manhattan"};
    if(tpl === "mustrows") rule = {type:"MustBeInRows", name:"Must be in rows", hard:true, pupil_id:a, r_min:0, r_max:1};

    rules.push(rule);
    $("txtRules").dataset.dirty = "";
    $("txtRules").value = JSON.stringify(rules, null, 2);
    readTextAreasIntoState();
    updateKPIs("Rule added.");
    saveLocal();
  }

  // --------- Demo content ---------
  function demoFill(){
    const pupils = [
      {id:"A", tags:["needs_front"], fixed:null},
      {id:"B", tags:["talkative"], fixed:null},
      {id:"C", tags:["talkative"], fixed:null},
      {id:"D", tags:[], fixed:null},
      {id:"E", tags:[], fixed:{r:1,c:0}},
      {id:"F", tags:[], fixed:null},
      {id:"G", tags:[], fixed:null},
      {id:"H", tags:[], fixed:null}
    ];

    const rules = [
      {type:"MinDistance", name:"A far from B", hard:true, a:"A", b:"B", d:3, metric:"manhattan"},
      {type:"NotAdjacent", name:"B not adjacent C", hard:true, a:"B", b:"C"},
      {type:"TagSeparation", name:"Spread talkative", hard:false, weight:5, tag:"talkative", min_d:4, metric:"manhattan"},
      {type:"PreferFront", name:"A prefers front", hard:false, weight:3, pupil_id:"A", k:2},
      {type:"PreferAwayFromTeacher", name:"B away from teacher", hard:false, weight:2, pupil_id:"B", min_d:3, metric:"manhattan"}
    ];

    state.pupils = pupils;
    state.rules = rules;

    $("txtPupils").dataset.dirty = "";
    $("txtRules").dataset.dirty = "";
    $("txtPupils").value = JSON.stringify(pupils, null, 2);
    $("txtRules").value = JSON.stringify(rules, null, 2);

    try{
      state.assignment = buildInitialAssignment(Number($("inpSeed").value||12345));
    }catch{ state.assignment = {}; }

    rebuildMap();
    saveLocal();
    toast("Demo loaded");
  }

  // --------- Wire up events ---------
  for(const btn of document.querySelectorAll(".toolBtn")){
    btn.addEventListener("click", () => setTool(btn.dataset.tool));
  }

  $("inpRows").addEventListener("change", () => {});
  $("inpCols").addEventListener("change", () => {});
  $("inpCell").addEventListener("change", () => {
    state.room.cell = clamp(Number($("inpCell").value||42), 28, 64);
    rebuildMap();
    saveLocal();
  });

  $("btnResize").addEventListener("click", () => {
    const newR = clamp(Number($("inpRows").value||8), 1, 40);
    const newC = clamp(Number($("inpCols").value||10), 1, 40);

    // Prune tiles that are out of bounds
    function inBoundsKey(k){
      const [r,c] = k.split(",").map(Number);
      return r>=0 && r<newR && c>=0 && c<newC;
    }
    state.room.blocked = new Set(Array.from(state.room.blocked).filter(inBoundsKey));
    state.room.teacher = new Set(Array.from(state.room.teacher).filter(inBoundsKey));

    const newSeats = new Map();
    for(const [k,v] of state.room.seats.entries()){
      if(inBoundsKey(k)) newSeats.set(k, v);
    }
    state.room.seats = newSeats;

    state.room.rows = newR;
    state.room.cols = newC;

    // repair assignment
    try{ state.assignment = repairAssignment(state.assignment||{}, Number($("inpSeed").value||12345)); }
    catch{ state.assignment = {}; }

    rebuildMap();
    saveLocal();
    toast("Grid resized");
  });

  $("txtPupils").addEventListener("input", () => { $("txtPupils").dataset.dirty = "1"; updateKPIs("Pupils edited."); });
  $("txtRules").addEventListener("input", () => { $("txtRules").dataset.dirty = "1"; updateKPIs("Rules edited."); });

  $("btnAddPupil").addEventListener("click", () => {
    const id = $("inpPupilId").value.trim();
    if(!id){ toast("Enter pupil ID"); return; }
    const tags = $("inpPupilTags").value.split(",").map(s=>s.trim()).filter(Boolean);
    const pupils = getPupils();
    if(pupils.some(p=>p.id===id)){ toast("ID exists"); return; }
    pupils.push({id, tags, fixed:null});
    $("txtPupils").dataset.dirty = "";
    $("txtPupils").value = JSON.stringify(pupils, null, 2);
    readTextAreasIntoState();
    try{ state.assignment = repairAssignment(state.assignment||{}, Number($("inpSeed").value||12345)); }catch{}
    rebuildMap();
    saveLocal();
    toast("Pupil added");
  });

  $("btnAutoFill").addEventListener("click", demoFill);
  $("btnAddRule").addEventListener("click", addRuleTemplate);

  $("btnShuffle").addEventListener("click", () => {
    readTextAreasIntoState();
    try{
      const seed = Number($("inpSeed").value||12345);
      state.assignment = buildInitialAssignment(seed);
      rebuildMap();
      saveLocal();
      toast("Shuffled");
    }catch(e){ toast(String(e.message||e)); }
  });

  $("btnStep").addEventListener("click", () => {
    readTextAreasIntoState();
    try{
      const seed = Number($("inpSeed").value||12345);
      const out = quickImprove({
        iters: 4000,
        t0: 2.5,
        t1: 0.05,
        seed,
        progressCb: (p) => {
          if(p.i % 800 === 0) updateKPIs(`Improving… best=${p.bestScore}`);
        }
      });
      state.assignment = out.assignment;
      rebuildMap();
      updateKPIs(out.bestScore===0 ? "Perfect score." : `Improved. score=${out.bestScore}`);
      saveLocal();
      toast("Improved");
    }catch(e){
      toast(String(e.message||e));
    }
  });

  $("btnSolve").addEventListener("click", async () => {
    readTextAreasIntoState();
    try{
      const restarts = clamp(Number($("inpRestarts").value||25), 1, 80);
      const iters = clamp(Number($("inpIters").value||25000), 100, 300000);
      const t0 = Math.max(0.05, Number($("inpT0").value||6.0));
      const t1 = Math.max(0.001, Number($("inpT1").value||0.05));
      const seed = Number($("inpSeed").value||12345);

      // prevent UI freeze: yield between restarts using a microtask
      let lastMsg = 0;
      const out = solve({
        restarts,
        itersPerRestart: iters,
        t0,
        t1,
        seed,
        progressCb: (p) => {
          const now = performance.now();
          if(now - lastMsg > 120){
            updateKPIs(`Solving… restart ${p.restart}/${p.restarts} · best=${p.bestScore}`);
            lastMsg = now;
          }
        }
      });

      state.assignment = out.assignment || {};
      rebuildMap();
      updateKPIs(out.bestScore===0 ? "Perfect score." : `Done. score=${out.bestScore}`);
      saveLocal();
      toast(out.bestScore===0 ? "Solved" : "Done");
    }catch(e){
      toast(String(e.message||e));
      updateKPIs("Error: " + String(e.message||e));
    }
  });

  $("btnExport").addEventListener("click", async () => {
    try{
      const data = exportJSON();
      const txt = JSON.stringify(data, null, 2);
      await navigator.clipboard.writeText(txt);
      toast("Copied JSON");
    }catch(e){
      // Clipboard may fail on some embedded browsers; fallback prompt
      const txt = JSON.stringify(exportJSON(), null, 2);
      prompt("Copy JSON:", txt);
    }
  });

  $("btnImport").addEventListener("click", () => {
    const txt = prompt("Paste JSON to import:");
    if(!txt) return;
    try{ importJSON(JSON.parse(txt)); toast("Imported"); }
    catch(e){ toast("Import failed"); }
  });

  $("btnReset").addEventListener("click", () => {
    if(!confirm("Reset everything?")) return;
    localStorage.removeItem("seating_planner_v"+MODEL_VERSION);
    location.reload();
  });

  $("btnEink").addEventListener("click", () => {
    document.body.classList.toggle("eink");
    toast(document.body.classList.contains("eink") ? "E‑Ink preview on" : "E‑Ink preview off");
  });

  // --------- Boot ---------
  function initDefaultMap(){
    // Minimal demo room: teacher tiles at top center, aisle in col 5, seats rows 1..6.
    state.room.rows = Number($("inpRows").value||8);
    state.room.cols = Number($("inpCols").value||10);
    state.room.cell = Number($("inpCell").value||42);

    // teacher
    state.room.teacher.add(keyRC(0,4));
    state.room.teacher.add(keyRC(0,5));

    // seats
    for(let r=1;r<=6;r++){
      for(let c=0;c<state.room.cols;c++){
        if(c===5) continue; // aisle
        ensureSeat(r,c);
      }
    }

    // blocked back wall row
    for(let c=0;c<state.room.cols;c++) ensureBlocked(7,c);

    // baseline pupils/rules
    state.pupils = [];
    state.rules = [];

    $("txtPupils").value = JSON.stringify(state.pupils, null, 2);
    $("txtRules").value = JSON.stringify(state.rules, null, 2);

    state.assignment = {};
  }

  (function boot(){
    setTool("seat");

    if(!loadLocal()){
      initDefaultMap();
      demoFill();
    } else {
      // ensure inputs reflect loaded
      $("inpRows").value = String(state.room.rows);
      $("inpCols").value = String(state.room.cols);
      $("inpCell").value = String(state.room.cell);

      // set textareas
      $("txtPupils").dataset.dirty = "";
      $("txtRules").dataset.dirty = "";
      $("txtPupils").value = JSON.stringify(state.pupils, null, 2);
      $("txtRules").value = JSON.stringify(state.rules, null, 2);
    }

    // repair assignment after any load
    try{ state.assignment = repairAssignment(state.assignment||{}, Number($("inpSeed").value||12345)); }
    catch{ state.assignment = {}; }

    rebuildMap();
    updateKPIs("Ready.");
  })();

  </script>
</body>
</html>
